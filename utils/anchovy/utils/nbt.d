/*
Copyright (c) 2013 Andrey Penechko

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license the "Software" to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module anchovy.utils.nbt;

private import std.bitmanip;
private import std.conv;
private import std.string;
private import std.zlib;

private import anchovy.utils.streamutils;

NbtBase ReadNbt(in ubyte[] inData){
	UnCompress uncompressor = new UnCompress(HeaderFormat.gzip);
	const(void)[] decData;
	try{
		decData = uncompressor.uncompress(inData);
		decData ~= uncompressor.flush();
	}catch(ZlibException){
		NbtException("Wrong Gzip data format");
	}
	
	ubyte[] data = cast(ubyte[])decData;
	return ReadTag( data );
}

void WriteNbt(NbtBase nbtbase, ref ubyte[] outData){
	ubyte[] data;
	Compress compressor=new Compress(9,HeaderFormat.gzip);
	
	outData ~= cast(ubyte[])compressor.compress(cast(const(void)[]) WriteTag(nbtbase)); 
	outData ~= cast(ubyte[])compressor.flush();
}

NbtBase ReadTag(ref ubyte[] inData){
	byte byte0= Read!byte( inData );
	if(byte0 == 0){
		return new NbtTagEnd();
	}
	else
	{
		NbtBase nbtbase = CreateTagOfType( byte0 );
		nbtbase.key = ReadString( inData );
		nbtbase.readTagValue( inData );
		return nbtbase;
	}
}

ref ubyte[] WriteTag( NbtBase nbtbase){
		ubyte[] data;
		return WriteTag(nbtbase, data);
}

ref ubyte[] WriteTag( NbtBase nbtbase,ref ubyte[] outData){
	outData~=nbtbase.getType();
	if(nbtbase.getType()==0)
	{
		NbtException("Empty data given");
	}else
	{
		WriteString(nbtbase.key,outData);
		nbtbase.writeTagValue(outData);
	}
	return outData;
}

NbtBase CreateTagOfType(ubyte type){
	switch(type){
		case 0:
			return new NbtTagEnd();
		case 1:
			return new NbtTagByte();
		case 2:
			return new NbtTagShort();
		case 3:
			return new NbtTagInt();
		case 4:
			return new NbtTagLong();
		case 5:
			return new NbtTagFloat();
		case 6:
			return new NbtTagDouble();
		case 7:
			return new NbtTagByteArray();
		case 8:
			return new NbtTagString();
		case 9:
			return new NbtTagList();
		case 10:
			return new NbtTagCompound();	
		default:
			return null;
	}
}

class NbtException:Exception{
	this(string message){
		super("NbtException: "~message);
	}
	
	static void opCall(string message){
		throw(new NbtException(message));
	}
}

abstract class NbtBase{
	
		abstract void readTagValue(ref ubyte[] inData);
		abstract void writeTagValue(ref ubyte[] outData);
		abstract byte getType();
		override abstract string toString();
	public:
		@property string key(){return _key;}
		@property string key(string key){return _key=key;}
		
	private:	
		string _key;
		byte _type;
}
 
class NbtTagEnd:NbtBase{
	public:
		override byte getType(){return 0;}
		override void readTagValue(ref ubyte[] inData){}
		override void writeTagValue(ref ubyte[] outData){}
		override string toString(){return "END";}
}

private string GenTag(string type, string typeId){
	return "class NbtTag"~type~":NbtBase{
	
		override void readTagValue(ref ubyte[] inData){
			"~toLower(type)~"Value = Read!"~toLower(type)~"( inData );
		}
		override void writeTagValue(ref ubyte[] outData){
			Write!"~toLower(type)~"(outData, "~toLower(type)~"Value);
		}
		
	public:
		override byte getType(){ return "~typeId~"; }
		override string toString(){return to!string("~toLower(type)~"Value);}
	private:
		"~toLower(type)~" "~toLower(type)~"Value;
	}";
}

mixin(GenTag("Byte","1"));
mixin(GenTag("Short","2"));
mixin(GenTag("Int","3"));
mixin(GenTag("Long","4"));
mixin(GenTag("Float","5"));
mixin(GenTag("Double","6"));

class NbtTagByteArray:NbtBase{
	
		override void readTagValue(ref ubyte[] inData){
			byteArrayValue = ReadArray!(byte)( inData, Read!int( inData ) );
		}
		override void writeTagValue(ref ubyte[] outData){
			Write!int(outData, byteArrayValue.length);
			outData~=cast(ubyte[])byteArrayValue;
		}
	public:
		override byte getType(){ return 7; }
		override string toString(){return "["~to!string(byteArrayValue.length)~" bytes]";}
	
	private:
		byte[] byteArrayValue;
}

class NbtTagString:NbtBase{
	
		override void readTagValue(ref ubyte[] inData){
			StringValue = ReadString( inData );
		}
		override void writeTagValue(ref ubyte[] outData){
			WriteString(StringValue,outData);
		}
	public:
		override byte getType(){ return 8; }
		override string toString(){return StringValue;}
	
	private:
		string StringValue;
}

class NbtTagList:NbtBase{
	
		override void readTagValue(ref ubyte[] inData){
			tagType = Read!byte(inData );
			int lng = Read!int( inData );
			NbtBase nbtbase; 
			for(size_t i=0;i<lng;++i){
				nbtbase = CreateTagOfType(tagType);
				nbtbase.readTagValue(inData);
				tagList~=nbtbase;
			}
		}
	
		override void writeTagValue(ref ubyte[] outData){
			Write!byte(outData, tagType);
			Write!int(outData, tagList.length);	
			foreach(tag;tagList){
				tag.writeTagValue(outData);
			}
		}
	
	
	public:
		override byte getType(){ return 9; }
	
		override string toString(){return to!string(tagList.length)~" entries of type"~NbtTagNames[tagType];}
	
		@property size_t length(){return tagList.length;}
	
		NbtBase opIndex(size_t index){return tagList[index];}
	
		ref NbtTagList opOpAssign(string op)(NbtBase rhs)
		if (op == "~"){
			tagList ~= rhs;
			return this;
		}
		NbtBase opIndexAssign(NbtBase rhs, size_t index){
			tagList[index]=rhs;
			return this;
		}
	private:
		NbtBase[] tagList;
		byte tagType;
}

class NbtTagCompound:NbtBase{
	
		override void readTagValue(ref ubyte[] inData){
			NbtBase nbtbase;
			while((nbtbase=ReadTag( inData )).getType()!=0){
				tagMap[nbtbase.key]=nbtbase;
			}
		}
		override void writeTagValue(ref ubyte[] outData){
			foreach(tag;tagMap.byValue()){
				WriteTag(tag,outData);
			}
			outData~=0;
		}
	
	public:
		override byte getType(){ return 10; }
		override string toString(){return to!string(tagMap.length)~" entries";}
	
		NbtBase opIndexAssign(NbtBase rhs, string index){
			tagMap[index]=rhs;
			return this;
		}	
		NbtBase opIndex(string index){return tagMap[index];}
	
		@property size_t length(){return tagMap.length;}
	private:
		NbtBase[string] tagMap;
}

string[11] NbtTagNames=	
	["Nbt_Tag_End",
	"Nbt_Tag_Byte",
	"Nbt_Tag_Short",
	"Nbt_Tag_Int",
	"Nbt_Tag_Long",
	"Nbt_Tag_Float",
	"Nbt_Tag_Double",
	"Nbt_Tag_Byte_Array" ,
	"Nbt_Tag_String",
	"Nbt_Tag_List",
	"Nbt_Tag_Compound" ];

private string ReadString(ref ubyte[] data){
	
	ubyte[2] shrt= data[0..2];
	short lng = bigEndianToNative!short(shrt);
	scope(exit){
		data=data[lng+2..$];
	}	
	return cast(string)cast(char[])data[2..lng+2];
}

private void WriteString( string str,ref ubyte[] outData ){
	
	Write!short( outData, cast(short)str.length );
	outData~=str;
}