/*
Copyright (c) 2013 Andrey Penechko

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license the "Software" to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module anchovy.gui.guiskin;

import anchovy.gui.all;
import anchovy.graphics.interfaces.irenderer;
import anchovy.graphics.texture;
import anchovy.core.types;

class GuiSkin
{
	string skinFilename;
	//May be replaced by atlas
	Texture texture;
	string textureFilename;
	string name;

	Font[string] fonts;
	FontInfo[] fontInfos;
	GuiStyle[string] styles;

	void addStyle(string styleName, GuiStyle style)
	{
		styles[styleName] = style;
	}

	void loadResources(IGuiRenderer guiRenderer)
	{
		texture = guiRenderer.renderer.createTexture(textureFilename);
		foreach(ref FontInfo info; fontInfos)
		{
			uint font = guiRenderer.fontManager.createFont(info.filename, info.size);
			fonts[info.name] = guiRenderer.fontManager.getFont(font);
		}
	}

	GuiStyle opIndex(string styleName)
	{
		return styles.get(styleName, null);
	}

	override string toString() const
	{
		string result;
		result ~= "GuiSkin(Name:'" ~ name~"', textureFilename: '"~textureFilename~"'\n";
		//result ~= "fonts: " ~ to!string(fonts);
		foreach(string styleName, ref style; styles)
		{
			result ~= styleName~"("~ style.toString ~ "\n";
		}
		result ~=")\n";
		return result;
	}
}

struct FontInfo
{
	string name;
	string filename;
	uint size;
}

class GuiStyle
{
	GuiStyleState[string] states;
	string fontName; // "normal" by default

	GuiStyleState opIndex(string stateName) const
	{
		const(GuiStyleState)* state = stateName in states;
		if (state is null) return states["normal"];
		return *state;
	}

	override string toString() const
	{
		return "fixedBord:"~to!string(states["normal"].fixedBorders.toString)~
			" contPadd:"~to!string(states["normal"].contentPadding.toString)~
				" rect:"~to!string(states["normal"].atlasRect)~
				"minSize: "~to!string(states["normal"].minSize);
	}
}

struct GuiStyleState
{
	///Defines position and sizes of controls texture in skin teture
	Rect atlasRect;

	/// Minimal size of the widget. If not explicitly specified equal to atlasRect size.
	/// It is highly recommended to set it to size equal or greater than atlasRect size to prevent glitches.
	ivec2 minSize;

	/// Maximal size of the widget. By default equal to [0,0]. If maxSize is zero maxSize is not limited.
	ivec2 maxSize;
	
	/// Defines offset of content rect from widget borders.
	RectOffset contentPadding;

	/// Defines outline of skin rect. Useful for drawing highlighting.
	RectOffset outline;
	
	/// Defines non-stretchable borders of texture.
	/// Corner parts will stay non-stretched.
	/// Left/right sides will be stretched vertically.
	/// Top/bottom sides will be stretched horizontally.
	/// Middle part will be stretched 
	RectOffset fixedBorders;
	
	Color textColor;
	Color backgroundColor;
}