/*
Copyright (c) 2013 Andrey Penechko

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license the "Software" to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module anchovy.graphics.shaderprogram;

import std.exception;
import std.stdio;
import std.string;
import std.variant;

public import derelict.opengl3.gl3;


struct Uniform
{
	uint location;
	uint type;
	uint num;
	float[4] lastValue;
}

class ShaderParameters
{

}


class ShaderProgram
{

public:

	/++
	 + Creates an empty shader program in OpenGL state.
	 + OpenGL must be initialized before creating.
	 +/
	this()
	{
		programHandler = glCreateProgram();
		_isInited = true;
	}

	this(in string vertShaderSource, in string fragShaderSource)
	{
		programHandler = glCreateProgram();

		attachShader(GL_VERTEX_SHADER, vertShaderSource);
		attachShader(GL_FRAGMENT_SHADER, fragShaderSource);

		_isInited = true;
	}

	void close()
	{
		if (_isInited)
		{
			glDeleteProgram(programHandler);
			_isInited = false;
		}
	}

	/++
	 + Binds shader to the current OpenGL state.
	 + Must be used only after attaching all the shaders and compilation.
	 + If compilation fails, no shader will be used.
	 +/
	void bind()
	{
		glUseProgram(programHandler);
	}

	static void unbind()
	{
		glUseProgram(0);
	}

	/++
	 + Compiles shader source of the given type and attaches it to the shader program.
	 + If shader compilation fails, writes compilation info to the error log of the shader program (_errorLog)
	 +
	 + Params:
	 + 		shaderType = GL_VERTEX_SHADER or GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER
	 + 		shaderSource = the string that contains the source of given shader
	 +/
	void attachShader(in GLenum shaderType, in string shaderSource)
	{

		GLuint shader = glCreateShader(shaderType);

		const char* fileData=toStringz(shaderSource);
		glShaderSource(shader, 1, &fileData, null);

		glCompileShader(shader);

		int status, length;
		glGetShaderiv(shader, GL_COMPILE_STATUS, &status);

		if (status == GL_FALSE)
		{
			glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &length);

			char[] error=new char[length];
			glGetShaderInfoLog(shader, length, null, cast(char*)error);

			string shaderTypeString;
			switch(shaderType)
			{
				case GL_VERTEX_SHADER:   shaderTypeString = "vertex"; break;
				case GL_GEOMETRY_SHADER: shaderTypeString = "geometry"; break;
				case GL_FRAGMENT_SHADER: shaderTypeString = "fragment"; break;
				default: break;
			}

			_errorLog ~= "Compile failure in " ~ shaderTypeString ~ " shader:\n" ~ error~"\n";
		}
		glAttachShader(programHandler, shader);
	}

	/++
	 + Compiles shaderProgram. If any error occurs, writes log to _errorLog.
	 + After compile detaches shaders from program.
	 + See_Also: errorLog
	 +/
	bool compile()
	{

		glLinkProgram(programHandler);

		GLint linkStatus;

		glGetProgramiv(programHandler, GL_LINK_STATUS, &linkStatus);

		/++
		 + Detaches all the shaders after compilation
		 +/
		scope(exit)
		{
			GLuint[3] shaders;
			GLsizei count;

			glGetAttachedShaders(programHandler, 3, &count, cast(uint*)shaders);

			for( uint i=0; i<count; ++i )
			{
				glDetachShader(programHandler, shaders[i]);
				glDeleteShader(shaders[i]);
			}
		}

		if ( linkStatus == GL_FALSE )
		{
			GLint infoLogLength;
			glGetProgramiv(programHandler, GL_INFO_LOG_LENGTH, &infoLogLength);

			char[] strInfoLog = new char[infoLogLength];
			glGetProgramInfoLog(programHandler, infoLogLength, null, cast(char*)strInfoLog);
			_errorLog ~= "Linker failure: " ~ strInfoLog ~ "\n";

			return false;
		}

		int total = -1;
		glGetProgramiv(programHandler, GL_ACTIVE_UNIFORMS, &total);
		for(int i=0; i<total; ++i)
		{
			int name_len = -1, num = -1;
			GLenum type = GL_ZERO;
			char[100] name;
			glGetActiveUniform(programHandler, i, name.length-1,
			                   &name_len, &num, &type, name.ptr);

			name[name_len] = 0;
			GLuint location = glGetUniformLocation(programHandler, name.ptr);
			string uniformName = name[0..name_len].idup;
			uniforms[uniformName] = Uniform(location, type, num);
		}
		// Magic bug. Cannot remove this statement
		writef("",uniforms);
		uniforms.rehash;

		return true;
	}

	/++
	 + Returns: empty string if the shader was compiled without	errors, or error log otherwise.
	 + Examples:
	 + ---
	 + if ( !myShaderProgram.compile ){
	 + 	  writeln( myShaderProgram.errorLog ); //Writes error log to console
	 + }
	 + ---
	 + See_Also: compile
	 +/
	@property string errorLog()
	{
		return _errorLog;
	}

	private static string getParType(T)()
	{
		string res;
		if (is(T : int) || is(T : byte) || is(T : short))
		{
			res = "i";
		}
		if (is(T : uint) || is(T : ubyte) || is(T : ushort))
		{
			res = "ui";
		}
		else if (is(T : float))
		{
			res = "f";
		}
		return res;
	}

	private static uint getGlType(T)()
	{
		uint type;
		static if (is(T : byte)) type = GL_BYTE;
		else if (is(T : ubyte)) type = GL_UNSIGNED_BYTE;
		else if (is(T : short)) type = GL_SHORT;
		else if (is(T : ushort)) type = GL_UNSIGNED_SHORT;
		else if (is(T : int)) type = GL_INT;
		else if (is(T : uint)) type = GL_UNSIGNED_INT;
		else if (is(T : float)) type = GL_FLOAT;
		else if (is(T : double)) type = GL_DOUBLE;
		return type;
	}
	//glUniform{1|2|3|4}{f|i|ui}v
	void setUniform(T)(string uniName, T t1)
	{
		Uniform* uni = &getUniform(uniName);
		if (uni.lastValue[0] != t1)
		{
			uni.lastValue[0] = t1;
			mixin("glUniform1"~getParType!T~"(uni.location, t1);");
		}
		/+for(uint i = 0; i<t.length-1; ++i)
		{
			params ~= "t["~to!string(i)~"], ";
		}
		params ~= "t["~to!string(t.length-1)~"]";
		//Uniform* uni = uniName in uniforms;
		assert(uni !is null, "Unknown uniform name");
		assert(uni.type == getGlType(t[0])(), "Wrong uniform type");

		writeln("glUniform1" ~
		        getParType!(typeof(t[0]))() ~
		        "(" ~
		        "uniName, " ~
		        params ~
		        ");");+/
	}

	void setUniform2(T)(string uniName, T t1, T t2)
	{
		Uniform* uni = &getUniform(uniName);
		if (uni.lastValue[0..2] != [t1,t2])
		{
			uni.lastValue[0..2] = [t1,t2];
			mixin("glUniform2"~getParType!T~"(uni.location, t1, t2);");
		}
	}

	void setUniform3(T)(string uniName, T t1, T t2, T t3)
	{
		Uniform* uni = &getUniform(uniName);
		if (uni.lastValue[0..3] != [t1, t2, t3])
		{
			uni.lastValue[0..3] = [t1, t2, t3];
			mixin("glUniform3"~getParType!T~"(uni.location, t1, t2, t3);");
		}
	}

	void setUniform4(T)(string uniName, T t1, T t2, T t3, T t4)
	{
		Uniform* uni = &getUniform(uniName);
		if (uni.lastValue[0..4] != [t1, t2, t3, t4])
		{
			uni.lastValue[0..4] = [t1, t2, t3, t4];
			mixin("glUniform4"~getParType!T~"(uni.location, t1, t2, t3, t4);");
		}
	}

	uint getUniformLoc(string name)
	{
		//assert((name in uniforms) !is null, "Unknown uniform: '"~name~"'");
		return uniforms[name].location;
	}

	ref Uniform getUniform(string name)
	{
		//assert((name in uniforms) !is null, "Unknown uniform: '"~name~"'");
		return uniforms[name];
	}

	/+
	 + Returns: shader program pointer of type GLuint, the result of glCreateProgram();
	 + Can be used in some OpenGL functions.
	 + Examples:
	 + ---
	 + myShaderProgram = new CShaderProgram();
	 + ---
	 + ...
	 + ---
	 + GLuint myShaderAttribute = glGetUniformLocation( myShaderProgram.program, "myShaderAttribute" );
	 + ---
	 +/
	@property GLuint program(){ return programHandler; }

	//void setUniform(T)(string unifName,
	//TODO: Add methods for uniforms setting

private:

	/++
	 + The result of glCreateProgram() get in constructor
	 +
	 + See_Also: this
	 +/
	GLuint programHandler = 0;
	Uniform[string] uniforms;

	/++
	 + The result of:
	 + ---
	 + glGetShaderiv( _shaderPointer, GL_COMPILE_STATUS, _compileStatus );
	 + ---
	 +/
	GLuint _compileStatus;

	/++
	 + Contains full compile log if compile error.
	 +/
	string _errorLog;

	bool _isInited;

}

static const string[uint] glTypes;

static this()
{
	glTypes = [
	           0x1400 : "GL_BYTE",
	           0x1401 : "GL_UNSIGNED_BYTE",
	           0x1402 : "GL_SHORT",
	           0x1403 : "GL_UNSIGNED_SHORT",
	           0x1404 : "GL_INT",
	           0x1405 : "GL_UNSIGNED_INT",
	           0x1406 : "GL_FLOAT",
	           0x140A : "GL_DOUBLE",];
}
